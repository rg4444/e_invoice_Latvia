"""Utilities for constructing DIV envelope structures.

This module focuses on generating the minimal set of elements required by
``examples/DIVEnvelope.xsd`` so that the payloads sent to the DIV Address
Lists service comply with the published schema.  The builder intentionally
populates only the sender facing portion of the envelope (``SenderDocument``)
because the remaining sections are filled in by the DIV infrastructure.
"""

from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import date
from typing import Iterable, List

from lxml import etree


DIV_ENVELOPE_NS = "http://ivis.eps.gov.lv/XMLSchemas/100001/DIV/v1-0"
DS_NS = "http://www.w3.org/2000/09/xmldsig#"


_RECIPIENT_SPLIT_RE = re.compile(r"[;,\s]+")
_TRACE_ID_SANITIZE_RE = re.compile(r"[^A-Za-z0-9_.-]")


@dataclass(frozen=True)
class EnvelopeMetadata:
    """Configuration knobs for the generated envelope."""

    author: str = "e-Rēķini Tester"
    document_kind_code: str = "E-INVOICE"
    document_kind_version: str = "1.0"
    priority: str = "normal"
    notify_sender_on_delivery: bool = False


def _qname(local: str) -> etree.QName:
    return etree.QName(DIV_ENVELOPE_NS, local)


def parse_recipient_list(raw: str) -> List[str]:
    """Return a cleaned list of recipient e-addresses.

    The DIV Address Lists service allows a single request to target multiple
    recipients.  Operators typically paste them separated by commas, newline
    characters or semicolons, so we support all three while ignoring empty
    tokens.
    """

    if not raw:
        return []

    recipients = [part.strip() for part in _RECIPIENT_SPLIT_RE.split(raw) if part.strip()]
    # Preserve the original order but drop accidental duplicates to avoid
    # schema validation errors caused by emitting empty RecipientEntry nodes.
    seen: set[str] = set()
    unique: list[str] = []
    for item in recipients:
        if item not in seen:
            unique.append(item)
            seen.add(item)
    return unique


def _sanitize_trace_id(value: str) -> str:
    """Return a safe identifier for ``TraceInfoID`` elements."""

    cleaned = _TRACE_ID_SANITIZE_RE.sub("-", value.strip()) if value else ""
    if not cleaned:
        return ""
    if cleaned[0].isdigit() or cleaned[0] == "-":
        cleaned = f"ID-{cleaned}"
    return cleaned


def build_div_envelope(
    *,
    sender_eaddress: str,
    recipients: Iterable[str],
    sender_reference: str,
    subject: str,
    body_text: str,
    metadata: EnvelopeMetadata | None = None,
    document_date: date | None = None,
    trace_entries: dict[str, str] | None = None,
) -> etree._Element:
    """Create a ``div:Envelope`` element compliant with ``DIVEnvelope.xsd``.

    Parameters
    ----------
    sender_eaddress:
        The sender's electronic address as registered in the Address Lists
        service.
    recipients:
        Iterable of recipient e-addresses.  At least one address must be
        provided.
    sender_reference:
        A unique identifier generated by the client for this envelope.  It is
        mapped to ``SenderRefNumber`` in the transport metadata section.
    subject:
        Human readable subject which becomes the document title.
    body_text:
        Descriptive text included as the envelope description.
    metadata:
        Optional :class:`EnvelopeMetadata` instance controlling fixed metadata
        fields such as author and document kind values.
    document_date:
        Overrides the ``Date`` field in the general metadata.  Defaults to
        :func:`datetime.date.today` when omitted.

    trace_entries:
        Optional mapping of identifier → value pairs that will be emitted as
        ``TraceInfo`` entries.  The identifiers are normalised to satisfy the
        ``xs:ID`` restrictions from the schema.

    Returns
    -------
    :class:`lxml.etree._Element`
        The fully populated ``div:Envelope`` element.

    Raises
    ------
    :class:`ValueError`
        If ``sender_eaddress`` is blank or the recipients list is empty.
    """

    if not sender_eaddress or not sender_eaddress.strip():
        raise ValueError("Sender e-address must be provided")

    recipient_list = [r.strip() for r in recipients if r and r.strip()]
    if not recipient_list:
        raise ValueError("At least one recipient e-address must be provided")

    info = metadata or EnvelopeMetadata()
    doc_date = document_date or date.today()

    envelope = etree.Element(_qname("Envelope"), nsmap={"div": DIV_ENVELOPE_NS, "ds": DS_NS})

    sender_document = etree.SubElement(envelope, _qname("SenderDocument"))
    sender_document.set("Id", "SenderSection")

    document_metadata = etree.SubElement(sender_document, _qname("DocumentMetadata"))
    general_metadata = etree.SubElement(document_metadata, _qname("GeneralMetadata"))

    authors = etree.SubElement(general_metadata, _qname("Authors"))
    author_entry = etree.SubElement(authors, _qname("AuthorEntry"))
    info_system = etree.SubElement(author_entry, _qname("InformationSystem"))
    info_system.text = info.author

    etree.SubElement(general_metadata, _qname("Date")).text = doc_date.isoformat()

    document_kind = etree.SubElement(general_metadata, _qname("DocumentKind"))
    etree.SubElement(document_kind, _qname("DocumentKindCode")).text = info.document_kind_code
    etree.SubElement(document_kind, _qname("DocumentKindVersion")).text = info.document_kind_version

    if body_text:
        etree.SubElement(general_metadata, _qname("Description")).text = body_text

    etree.SubElement(general_metadata, _qname("Title")).text = subject or "Untitled document"

    sender_transport = etree.SubElement(sender_document, _qname("SenderTransportMetadata"))
    etree.SubElement(sender_transport, _qname("SenderE-Address")).text = sender_eaddress
    etree.SubElement(sender_transport, _qname("SenderRefNumber")).text = sender_reference

    recipients_el = etree.SubElement(sender_transport, _qname("Recipients"))
    for recipient in recipient_list:
        entry = etree.SubElement(recipients_el, _qname("RecipientEntry"))
        etree.SubElement(entry, _qname("RecipientE-Address")).text = recipient

    etree.SubElement(
        sender_transport,
        _qname("NotifySenderOnDelivery"),
    ).text = "true" if info.notify_sender_on_delivery else "false"

    etree.SubElement(sender_transport, _qname("Priority")).text = info.priority

    if trace_entries:
        trace_info = etree.SubElement(sender_transport, _qname("TraceInfo"))
        for key, value in trace_entries.items():
            trace_id = _sanitize_trace_id(key)
            trace_text = (value or "").strip()
            if not trace_id or not trace_text:
                continue
            entry = etree.SubElement(trace_info, _qname("TraceInfoEntry"))
            etree.SubElement(entry, _qname("TraceInfoID")).text = trace_id
            etree.SubElement(entry, _qname("TraceText")).text = trace_text[:50]

    # ``Signatures`` is required by the schema even if the caller does not sign
    # the envelope.  Emit an empty skeleton so the payload validates and DIV can
    # replace it with actual signatures during processing.
    signatures = etree.SubElement(envelope, _qname("Signatures"))
    signature = etree.SubElement(signatures, etree.QName(DS_NS, "Signature"))

    signed_info = etree.SubElement(signature, etree.QName(DS_NS, "SignedInfo"))
    etree.SubElement(
        signed_info,
        etree.QName(DS_NS, "CanonicalizationMethod"),
        Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315",
    )
    etree.SubElement(
        signed_info,
        etree.QName(DS_NS, "SignatureMethod"),
        Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1",
    )
    reference = etree.SubElement(signed_info, etree.QName(DS_NS, "Reference"))
    reference.set("URI", "")
    transforms = etree.SubElement(reference, etree.QName(DS_NS, "Transforms"))
    etree.SubElement(
        transforms,
        etree.QName(DS_NS, "Transform"),
        Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature",
    )
    etree.SubElement(
        reference,
        etree.QName(DS_NS, "DigestMethod"),
        Algorithm="http://www.w3.org/2000/09/xmldsig#sha1",
    )
    etree.SubElement(reference, etree.QName(DS_NS, "DigestValue")).text = ""

    etree.SubElement(signature, etree.QName(DS_NS, "SignatureValue")).text = ""
    etree.SubElement(signature, etree.QName(DS_NS, "KeyInfo"))

    return envelope

