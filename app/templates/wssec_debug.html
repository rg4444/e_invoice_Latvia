{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
  <h2>WS-Security debug – GetInitialAddresseeRecordList</h2>

  <p class="text-muted">
    This page lets you run a series of WS-Security profiles (algorithms, signed parts, header order)
    against the DIV UnifiedServiceInterface <code>GetInitialAddresseeRecordList</code> operation.
    Use it to compare scenarios and identify why the service returns
    <code>a:InvalidSecurity</code>.
  </p>
  <p class="text-muted small">
    Calls from this tab go to the special debug endpoint provided by VDAA:<br>
    <code>{{ cfg.debug_endpoint or 'https://divtest.vraa.gov.lv/Vraa.Div.WebService.UnifiedInterfaceDebug/UnifiedService.svc' }}</code><br>
    Normal Address tab requests continue to use the standard UnifiedService endpoint.
  </p>

  <div class="card mb-3">
    <div class="card-header">Engine availability</div>
    <div class="card-body">
      <ul class="list-unstyled mb-0">
        <li>
          <span class="badge bg-{{ 'success' if engine_caps.python.available else 'danger' }}">
            {{ 'Available' if engine_caps.python.available else 'Unavailable' }}
          </span>
          Python engine (custom WSSE)
        </li>
        <li>
          <span class="badge bg-{{ 'success' if engine_caps.dotnet.available else 'danger' }}">
            {{ 'Available' if engine_caps.dotnet.available else 'Unavailable' }}
          </span>
          .NET bridge ({{ engine_caps.dotnet.detail }})
        </li>
        <li>
          <span class="badge bg-{{ 'success' if engine_caps.java.available else 'danger' }}">
            {{ 'Available' if engine_caps.java.available else 'Unavailable' }}
          </span>
          Java bridge ({{ engine_caps.java.detail }})
        </li>
      </ul>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-header">
      Test parameters
    </div>
    <div class="card-body">
      <form id="wssec_form">
        <div class="mb-3">
          <label for="wssec_engine" class="form-label">SOAP Engine</label>
          <select class="form-select" id="wssec_engine" name="engine">
            <option value="python" selected>Python (custom WSSE)</option>
            <option value="dotnet">.NET (VDAA SDK)</option>
            <option value="java">Java (VDAA SDK)</option>
          </select>
          <div class="form-text">
            Use .NET/Java for official VDAA SDK behaviour; use Python for custom experiments.
          </div>
        </div>

        <div class="mb-3">
          <label for="wssec_operation" class="form-label">Operation</label>
          <select class="form-select" id="wssec_operation" name="operation">
            <option value="GetInitialAddresseeRecordList" selected>GetInitialAddresseeRecordList</option>
          </select>
          <div class="form-text">
            Additional operations can be added later as needed.
          </div>
        </div>

        <div class="form-check mb-3">
          <input class="form-check-input" type="checkbox" id="wssec_use_debug" name="use_debug" checked>
          <label class="form-check-label" for="wssec_use_debug">
            Use Debug endpoint
          </label>
        </div>

        <div class="mb-3">
          <label for="wssec_token" class="form-label">Token value (uui:Token)</label>
          <input type="text" class="form-control" id="wssec_token" name="token" placeholder="1">
          <div class="form-text">
            For the initial address list, this can usually be left blank or set to <code>1</code>.
          </div>
        </div>

        <div class="mb-3" id="wssec_scenario_group">
          <label for="wssec_scenario" class="form-label">Scenario</label>
          <select class="form-select" id="wssec_scenario" name="scenario">
            <option value="all" selected>Run all scenarios</option>
            <option value="sha1_body_timestamp">SHA1 – sign Body + Timestamp</option>
            <option value="sha1_body_ts_action_to">SHA1 – sign Body + Timestamp + Action + To</option>
            <option value="sha256_body_timestamp">SHA256 – sign Body + Timestamp</option>
            <option value="sha256_body_ts_action_to">SHA256 – sign Body + Timestamp + Action + To</option>
            <option value="policy_compliant">Policy-compliant (SDK WSDL)</option>
          </select>
          <div class="form-text">
            Start with "Run all scenarios" to compare behaviour.
          </div>
        </div>

        <button type="button" id="wssec_run" class="btn btn-primary">
          Run WS-Security tests
        </button>
      </form>
    </div>
  </div>

  <div class="card">
    <div class="card-header">
      Results
    </div>
    <div class="card-body">
      <pre id="wssec_result"
           class="bg-dark text-light p-3 rounded small"
           style="max-height: 420px; overflow-y: auto; font-family: monospace;"
           hidden></pre>
      <p class="text-muted mt-2 small">
        Each scenario saves the full request and response to
        <code>data/addresses/wssec_debug/</code> for offline inspection.
        The saved request XMLs will mention the debug endpoint to help VDAA match your tests with their logs.
      </p>
    </div>
  </div>
</div>

<script>
(async function() {
  const form = document.getElementById('wssec_form');
  const runBtn = document.getElementById('wssec_run');
  const resultBox = document.getElementById('wssec_result');
  const engineSelect = document.getElementById('wssec_engine');
  const scenarioGroup = document.getElementById('wssec_scenario_group');
  const scenarioSelect = document.getElementById('wssec_scenario');
  const operationSelect = document.getElementById('wssec_operation');

  function updateEngineUI() {
    const engine = engineSelect.value;
    const isPython = engine === 'python';
    scenarioGroup.hidden = !isPython;
    scenarioSelect.disabled = !isPython;
    runBtn.textContent = isPython ? 'Run WS-Security tests' : 'Run SDK call';
  }

  async function callWssecDebug() {
    const fd = new FormData(form);
    const token = document.getElementById('wssec_token').value.trim();
    const engine = engineSelect.value;
    const useDebug = document.getElementById('wssec_use_debug').checked;
    const operation = operationSelect.value;
    if (!token) {
      // optional: allow blank token for experimentation
    }
    fd.set('engine', engine);
    fd.set('endpoint_mode', useDebug ? 'debug' : 'normal');

    resultBox.hidden = false;
    resultBox.textContent = engine === 'python'
      ? "Running WS-Security scenarios...\n"
      : "Running SDK call...\n";

    try {
      let data = null;
      if (engine === 'python') {
        const resp = await fetch('/wssec-debug/run', {
          method: 'POST',
          body: fd
        });
        data = await resp.json();
      } else {
        const payload = {
          engine: engine,
          operation: operation,
          token: token,
          use_debug_endpoint: useDebug
        };
        const resp = await fetch('/api/wssec-debug/run-sdk-call', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        data = await resp.json();
      }

      let lines = [];
      if (!data.ok) {
        lines.push("Error: " + (data.error || data.fault_reason || "Unknown error"));
        if (data.fault_reason && data.error && data.fault_reason !== data.error) {
          lines.push("Fault reason: " + data.fault_reason);
        }
        if (data.stderr) {
          lines.push("stderr: " + data.stderr);
        }
      } else if (engine === 'python') {
        for (const r of data.results) {
          lines.push("Scenario: " + r.scenario + " (" + (r.label || "") + ")");
          lines.push("  Engine: " + (r.engine || "?") + " | Operation: " + (r.operation || "?"));
          lines.push("  Endpoint: " + (r.endpoint || "?") + " (" + (r.endpoint_mode || "debug") + ")");
          lines.push("  Sent: " + (r.sent_utc || "?") + " | MessageID: " + (r.message_id || "?"));
          lines.push("  HTTP status: " + (r.http_status ?? "?") + " | Duration: " + (r.took_ms ?? "?") + " ms");
          if (r.request_saved_path) {
            lines.push("  Saved request: " + r.request_saved_path);
          }
          if (r.response_saved_path) {
            lines.push("  Saved response: " + r.response_saved_path);
          }
          if (r.parsed_saved_path) {
            lines.push("  Saved parsed list: " + r.parsed_saved_path);
          }
          if (r.fault_reason) {
            lines.push("  Fault reason: " + r.fault_reason);
          }
          if (r.stderr) {
            lines.push("  stderr: " + r.stderr);
          }
          if (r.policy_mode) {
            lines.push("  WSDL policy mode: ON");
          }
          lines.push("");
        }
      } else {
        lines.push("Engine: " + (data.engine || engine) + " | Operation: " + (data.operation || operation));
        lines.push("Endpoint: " + (data.endpoint || "?") + " (" + (data.endpoint_mode || "debug") + ")");
        lines.push("HTTP status: " + (data.http_status ?? "?") + " | Duration: " + (data.took_ms ?? "?") + " ms");
        const savedRequest = data.saved_request_path || data.request_saved_path;
        const savedResponse = data.saved_response_path || data.response_saved_path;
        if (savedRequest) {
          lines.push("Saved request: " + savedRequest);
        }
        if (savedResponse) {
          lines.push("Saved response: " + savedResponse);
        }
        if (data.fault_reason) {
          lines.push("Fault reason: " + data.fault_reason);
        }
        if (data.stderr) {
          lines.push("stderr: " + data.stderr);
        }
      }

      resultBox.textContent = lines.join("\n") + "\n\n--- Raw JSON ---\n" +
                              JSON.stringify(data, null, 2);
    } catch (err) {
      resultBox.textContent += "\nERROR: " + err;
    }
  }

  engineSelect.addEventListener('change', updateEngineUI);
  updateEngineUI();
  runBtn.addEventListener('click', callWssecDebug);
})();
</script>
{% endblock %}
